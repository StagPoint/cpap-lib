using System;
using System.Collections.Generic;
using System.Linq;

using Microsoft.Win32;
// ReSharper disable ConvertIfStatementToSwitchStatement

namespace cpaplib
{
	public class DailyReport : IComparable<DailyReport>
	{
		#region Public properties

		/// <summary>
		/// The unique identifier for this instance
		/// </summary>
		public int ID { get; set; } = -1;
		
		/// <summary>
		/// The date for which this report was generated (ie, "Report for the night of Dec 12, 2023")
		/// </summary>
		public DateTime ReportDate { get; set; }
		
		/// <summary>
		/// The specific time at which recording began
		/// </summary>
		public DateTime RecordingStartTime { get; set; }
		
		/// <summary>
		/// The specific time at which recording ended
		/// </summary>
		public DateTime RecordingEndTime { get; set; }
		
		/// <summary>
		/// Returns the total time between the start of the first session and the end of the last session
		/// </summary>
		public TimeSpan TotalTimeSpan { get => RecordingEndTime - RecordingStartTime; }

		/// <summary>
		/// Returns true if this instance contains detailed Signal and Event data, or false if not (such as when the user
		/// did not have an SD card in the machine). This value is set during import and is never updated.
		/// </summary>
		public bool HasDetailData { get; set; }

		/// <summary>
		/// Returns the number of "Mask Times" for the day
		/// </summary>
		internal int MaskEvents { get; set; }

		/// <summary>
		/// The total amount of time the CPAP was used on the reported day (calculated)
		/// </summary>
		public TimeSpan TotalSleepTime { get; set; }

		/// <summary>
		/// Identifies the machine that was used to record this report 
		/// </summary>
		public MachineIdentification MachineInfo { get; set; } = new MachineIdentification();
		
		/// <summary>
		/// The settings (pressure, EPR, response type, etc.) used on this day
		/// </summary>
		public MachineSettings Settings { get; set; } = new MachineSettings();

		/// <summary>
		/// The list of sessions  for this day
		/// </summary>
		public List<Session> Sessions { get; set; } = new List<Session>();

		/// <summary>
		/// A summary of event indices (like Apnea/Hypopnea Index) reported by the machine.
		/// This summary is generated during import and is never updated. 
		/// </summary>
		public EventSummary EventSummary { get; set; } = new EventSummary();
		
		/// <summary>
		/// A summary of the statistics such as Tidal Volume, Minute Ventilation, Pressure, etc.
		/// that was reported by the machine.
		/// This summary is generated during import and is never updated. 
		/// </summary>
		public StatisticsSummary StatsSummary { get; set; }

		/// <summary>
		/// The list of events that were reported by the machine (or generated by other processes)
		/// </summary>
		public List<ReportedEvent> Events { get; set; } = new List<ReportedEvent>();

		/// <summary>
		/// Usage and performance statistics for this day (average pressure, leak rate, etc.)
		/// </summary>
		public List<SignalStatistics> Statistics { get; set; } = new List<SignalStatistics>();

		/// <summary>
		/// Any notes that should be saved along with this daily report
		/// </summary>
		public string Notes { get; set; } = string.Empty;

		/// <summary>
		/// The list of <see cref="Annotation"/> items entered by the user for this <see cref="DailyReport"/>
		/// </summary>
		public List<Annotation> Annotations { get; set; } = new List<Annotation>();

		#endregion 

		#region Public functions

		/// <summary>
		/// Recalculates the EventSummary values 
		/// </summary>
		public void UpdateEventSummary()
		{
			var tst = TotalSleepTime.TotalHours;

			var apneaEvents = Events.Where( x => EventTypes.Apneas.Contains( x.Type ) ).ToArray();
			
			EventSummary.AHI                      = apneaEvents.Length / tst;
			EventSummary.PeakAHI                  = calculatePeakAHI();
			EventSummary.ApneaIndex               = apneaEvents.Count( x => x.Type != EventType.Hypopnea );
			EventSummary.HypopneaIndex            = Events.Count( x => x.Type == EventType.Hypopnea ) / tst;
			EventSummary.ObstructiveApneaIndex    = Events.Count( x => x.Type == EventType.ObstructiveApnea ) / tst;
			EventSummary.CentralApneaIndex        = Events.Count( x => x.Type == EventType.ClearAirway ) / tst;
			EventSummary.UnclassifiedApneaIndex   = Events.Count( x => x.Type == EventType.UnclassifiedApnea ) / tst;
			EventSummary.RespiratoryArousalIndex  = Events.Count( x => x.Type == EventType.RERA ) / tst;
			EventSummary.CheynesStokesRespiration = Events.Count( x => x.Type == EventType.CSR ) / tst;

			return;
			
			double calculatePeakAHI()
			{
				var window    = new List<DateTime>( apneaEvents.Length );
				var peakCount = 0;

				foreach( var e in apneaEvents )
				{
					var currentTime = e.StartTime;
					window.Add( currentTime );

					var thresholdTime = currentTime.AddHours( -1 );
					while( window.Count > 0 && window[ 0 ] < thresholdTime )
					{
						window.RemoveAt( 0 );	
					}

					peakCount = Math.Max( peakCount, window.Count );
				}

				return peakCount;
			}
		}

		/// <summary>
		/// Recalculates the statistics for the named Signal. Designed to be called after a data import to
		/// update the statistics to account for the newly imported data. 
		/// </summary>
		public void UpdateSignalStatistics( string signalName )
		{
			Statistics.RemoveAll( x => x.SignalName.Equals( signalName ) );

			var calculator = new SignalStatCalculator();
			var stats      = calculator.CalculateStats( signalName, Sessions );

			if( stats != null )
			{
				Statistics.Add( stats );
			}
		}
		
		/// <summary>
		/// Updates the RecordingStartTime, RecordingEndTime, and TotalSleepTime properties to reflect
		/// any changes to the Sessions collection.
		/// </summary>
		public void RefreshTimeRange()
		{
			RecordingStartTime = Sessions.Min( x => x.StartTime );
			RecordingEndTime   = Sessions.Max( x => x.EndTime );
			TotalSleepTime     = CalculateTotalSleepTime();
		}

		/// <summary>
		/// Adds a new Session to the Sessions list and updates the RecordingStartTime and RecordingEndTime
		/// properties if necessary.
		/// </summary>
		/// <param name="session"></param>
		public void AddSession( Session session )
		{
			Sessions.Add( session );
			
			RecordingStartTime = DateUtil.Min( RecordingStartTime, session.StartTime );
			RecordingEndTime   = DateUtil.Max( RecordingEndTime, session.EndTime );

			TotalSleepTime =  CalculateTotalSleepTime();
			HasDetailData  |= session.Signals.Count > 0;

			Sessions.Sort();
		}

		/// <summary>
		/// Removes a Session from the Sessions list, as well as any associated events. Updates the
		/// signal statistics for all Signals in the Session, and updates the RecordingStartTime and
		/// RecordingEndTime properties if necessary. 
		/// </summary>
		protected bool RemoveSession( Session session )
		{
			if( !Sessions.Remove( session ) )
			{
				return false;
			}

			Events.RemoveAll( x =>
				x.SourceType == session.SourceType &&
				x.StartTime >= session.StartTime &&
				x.StartTime <= session.EndTime
			);
			
			foreach( var signal in session.Signals )
			{
				if( Statistics.Any( x => x.SignalName == signal.Name ) )
				{
					UpdateSignalStatistics( signal.Name );
				}
			}

			RefreshTimeRange();
			UpdateEventSummary();

			return true;
		}
		
		/// <summary>
		/// Calculates the TotalSleepTime value by adding the duration of all sessions generated by a CPAP machine.
		/// </summary>
		/// <returns></returns>
		public TimeSpan CalculateTotalSleepTime()
		{
			// Total Sleep Time only refers to sessions that were generated by the CPAP
			return TimeSpan.FromSeconds( Sessions.Where( x => x.SourceType == SourceType.CPAP ).Sum( x => x.Duration.TotalSeconds ) );
		}

		/// <summary>
		/// Calculates the Sleep Efficiency ("mask off time" / "mask on time") value for this day.
		/// </summary>
		/// <returns></returns>
		public double CalculateSleepEfficiency()
		{
			var sessions    = Sessions.Where( x => x.SourceType == SourceType.CPAP ).ToArray();
			var maskOffTime = TimeSpan.Zero;

			if( sessions.Length <= 1 )
			{
				return sessions.Length;
			}

			for( int i = 1; i < sessions.Length; i++ )
			{
				maskOffTime += sessions[ i ].StartTime - sessions[ i - 1 ].EndTime;
			}

			return 1.0 - Math.Min( maskOffTime.TotalMinutes / sessions.Sum( x => x.Duration.TotalMinutes ), 1.0 );
		}

		/// <summary>
		/// Merges Session data with existing Sessions when possible, or adds it if there are no coincident Sessions
		/// to merge with. Note that the Session being passed must still overlap the time period of this DailyReport,
		/// and an exception will be thrown if that is not the case.  
		/// </summary>
		public void MergeSession( Session session )
		{
			if( RecordingStartTime > session.EndTime || RecordingEndTime < session.StartTime )
			{
				throw new Exception( $"Session from {session.StartTime} to {session.EndTime} does not overlap reporting period for {ReportDate.Date} and cannot be merged." );
			}
			
			// There are two obvious options here: Merge the new session's signals into an existing session, or 
			// simply add the new session to the list of the day's sessions. 
			//
			// The first option will potentially involve fixing up start and end times, and might have more 
			// non-obvious edge cases to worry about, but the second option creates a situation where all 
			// sessions only contain a subset of the available data for a given period of time, which sort of
			// breaks the original design of what a session entails.
			//
			// When merging into an existing session, there is the question of whether to extend the session
			// start and end times if the new data exceeds them, or whether to trim the new data to match 
			// those times if needed. Consider adding pulse oximetry data to a session containing CPAP flow
			// pressure data (among others) when the pulse oximetry data starts a few seconds before the CPAP
			// data starts and ends a minute after the CPAP session ends; The user probably cares more about
			// the CPAP data and wants to see what their blood oxygen levels were during the CPAP therapy,
			// and may not necessarily care about values that lie outside of the "mask on" period. 
			//

			foreach( var existingSession in Sessions )
			{
				bool disjoint = (existingSession.StartTime > session.EndTime || existingSession.EndTime < session.StartTime);
				if( !disjoint )
				{
					// When merging with an existing Session, all of the merged Signals will be trimmed to fit the 
					// destination Session's time period. 
					existingSession.Merge( session );
					
					return;
				}
			}

			Sessions.Add( session );
			Sessions.Sort( ( lhs, rhs ) => lhs.StartTime.CompareTo( rhs.StartTime ) );
			
			RecordingStartTime = DateUtil.Min( RecordingStartTime, session.StartTime );
			RecordingEndTime   = DateUtil.Max( RecordingEndTime, session.EndTime );

			TotalSleepTime = CalculateTotalSleepTime();
		}

		public static bool TimesOverlap( DailyReport day, Session session )
		{
			return DateHelper.RangesOverlap( day.RecordingStartTime, day.RecordingEndTime, session.StartTime, session.EndTime );
		}

		#endregion
		
		#region IComparable<DailyReport> interface implementation 
		
		public int CompareTo( DailyReport other )
		{
			return other == null ? 0 : ReportDate.Date.CompareTo( other.ReportDate.Date );
		}

		#endregion 

		#region Base class overrides

		public override string ToString()
		{
			if( Sessions.Count > 0 )
			{
				return $"{ReportDate.ToLongDateString()}   {Sessions.First().StartTime.ToShortTimeString()} - {Sessions.Last().EndTime.ToShortTimeString()}    ({TotalSleepTime})";
			}

			return $"{ReportDate.ToLongDateString()}   ({TotalSleepTime})";
		}

		#endregion
	}
}
